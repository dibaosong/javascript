<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>选择排序</title>
</head>
<body>
	<div>
		<h2>解释：</h2>
		对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。
		<h2>算法稳定性</h2>
		选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。
	</div>
	<script>
		function selectionSort(arr){
			var len = arr.length,
				minIndex,
				temp;
			for(var i = 0; i < len - 1; i++){
				minIndex = i;
				for(var j = i + 1; j < len; j++){
					if(arr[j] < arr[minIndex]){
						minIndex = j;
					};
				};
				temp = arr[i];
				arr[i] = arr[minIndex];
				arr[minIndex] = temp;
			};
			return arr;
		};

		var arr = [11, 15, 2, 6];
		var newArr = selectionSort(arr);
		console.log(newArr)
	</script>
</body>
</html>